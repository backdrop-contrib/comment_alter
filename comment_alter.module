<?php
// $Id$

/**
 * @file
 * Provides UI to alter nodes' parameters from comment forms.
 *
 * @author
 * CSÉCSY László <boobaa@kybest.hu>
 */

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * @see comment_alter_form_field_ui_field_edit_form_alter_submit()
 */
function comment_alter_form_field_ui_field_edit_form_alter(&$form, &$form_state, $form_id) {
  // Image fields and file fields are not supported by now, peroid.
  if ($form['#field']['type'] == 'image' || $form['#field']['type'] == 'file') {
    return;
  }
  if ($form['instance']['entity_type']['#value'] == 'node') {
    $form['#comment_alter'] = array(
      '#type' => 'value',
      '#value' => variable_get('comment_alter_' . $form['instance']['bundle']['#value'], array()),
    );
    $form['instance']['comment_alter'] = array(
      '#type' => 'checkbox',
      '#title' => t('Enable altering this field from comments.'),
      '#weight' => $form['instance']['required']['#weight'] + 0.5,
      '#default_value' => isset($form['#comment_alter']['#value'][$form['instance']['field_name']['#value']]) ? $form['#comment_alter']['#value'][$form['instance']['field_name']['#value']] : FALSE,
    );
    $form['#submit'][] = 'comment_alter_form_field_ui_field_edit_form_alter_submit';
    // XXX: Check if this submit callback needed at all, or the checkbox
    // status gets stored to the field (instance) settings.
  }
}

/**
 * Stores status of comment-alterable checkbox.
 *
 * @see comment_alter_form_field_ui_field_edit_form_alter()
 */
function comment_alter_form_field_ui_field_edit_form_alter_submit($form, &$form_state) {
  // Store only those field names that have been set to be comment-alterable
  // for performance reasons.
  $comment_alter = $form['#comment_alter']['#value'];
  $comment_alter[$form['instance']['field_name']['#value']] = $form_state['values']['instance']['comment_alter'];
  $comment_alter = array_filter($comment_alter);
  variable_set('comment_alter_' . $form['instance']['bundle']['#value'], $comment_alter);
}


/**
 * Implements hook_form_alter().
 */
function comment_alter_form_alter(&$form, &$form_state, $form_id) {
  if ($form['#id'] == 'comment-form') {
    $edit_comment = !empty($form['cid']['#value']);
    $node = $form['#node'];
    $type = node_type_get_type($node);
    $comment_alter_fields = array_keys(variable_get('comment_alter_' . $node->type, array()));
    // Add widgets to comment form if comment form is new,
    // and if comment alter fields are available.
    if (empty($form['cid']['#value']) && !empty($comment_alter_fields)) {
      // OK, let's twist things a little bit. Save our precious $form, call
      // field_attach_form() which modifies it (by adding the fields),
      // save the full form with all the fields, restore our precious saved
      // form without the fields, and add only the needed fields to it.
      // Simple, isn't it? Weird, but works; patches welcome for a less
      // resource-hungry version (or simply 'better', by any means).
      $precious_form = $form;
      field_attach_form('node', $node, $form, $form_state, $node->language);
      $full_form = $form;
      $form = $precious_form;
      $field_info = field_info_extra_fields('comment', 'comment_node_' . $node->type, 'form');

      foreach ($comment_alter_fields as $field) {
        if (!empty($full_form[$field]) && $full_form[$field]['#access']) {
          $field_language = $full_form[$field]['#language'];
          $form['comment_alter']['old'][$field] = array(
            '#type' => 'value',
            '#value' => array($field_language => $node->{$field}[$field_language]),
          );
          $form['comment_alter']['new'][$field] = $full_form[$field];
          // TODO: This doesn't seem to be working properly: if the extra field
          // is set to last, it even gets displayed above comment subject.
          $form['comment_alter']['new'][$field]['#weight'] = $field_info[$field]['weight'];
        }
      }

      if (!empty($form['comment_alter'])) {
        $form['comment_alter']['#tree'] = TRUE;
        $form['comment_alter']['old_vid'] = array(
          '#type' => 'value',
          '#value' => $node->vid,
        );
      }
    }
  }
}

/**
 * Implements hook_comment_insert().
 */
function comment_alter_comment_insert($comment) {
  // Do not try to save anything if there is nothing that was allowed to be
  // changed from the comment form.
  if (isset($comment->comment_alter)) {
    $node = node_load($comment->nid);
    $node_changed = FALSE;
    foreach ($comment->comment_alter['new'] as $field => $value) {
      if ($comment->comment_alter['old'][$field] != $value) {
        foreach ($value[$node->language] as $delta => $deltavalue) {
          foreach ($deltavalue as $subfield => $subvalue) {
            if ($comment->comment_alter['old'][$field][$node->language][$delta][$subfield] != $subvalue) {
              $node_changed = TRUE;
              $node->{$field}[$node->language][$delta][$subfield] = $subvalue;
            }
          }
        }
      }
    }
    if ($node_changed) {
      // Creating a new node revision regardless the node type settings.
      $node->revision = TRUE;
      node_save($node);
      $comment_alter = array(
        'old_vid' => $comment->comment_alter['old_vid'],
        'new_vid' => $node->vid,
        'cid' => $comment->cid,
      );
      drupal_write_record('comment_alter', $comment_alter);
    }
    // Unsetting $comment->comment_alter is not needed.
  }
}

/**
 * Implements hook_comment_load().
 */
function comment_alter_comment_load($comments) {
  $result = db_query('SELECT cid, old_vid, new_vid FROM {comment_alter} WHERE cid IN (:cids)', array(':cids' => array_keys($comments)));
  foreach ($result as $row) {
    $comments[$row->cid]->comment_alter['old_vid'] = $row->old_vid;
    $comments[$row->cid]->comment_alter['new_vid'] = $row->new_vid;
  }
}

/**
 * Implements hook_comment_view().
 *
 * @see diff_diffs_show()
 */
function comment_alter_comment_view($comment, $view_mode, $langcode) {
  if (($view_mode == 'full') && isset($comment->comment_alter) && isset($comment->comment_alter['old_vid']) && !empty($comment->comment_alter['old_vid'])) {
    $node = node_load($comment->nid);
    $old_vid = &$comment->comment_alter['old_vid'];
    $new_vid = &$comment->comment_alter['new_vid'];
    module_load_include('inc', 'diff', 'diff.pages');

    // A stripped-down version of diff_diffs_show().
    // Attaches the CSS.
    $build['#attached'] = diff_build_attachments();
    $state = variable_get('diff_default_state_node', 'raw');
    $node_revisions = node_revision_list($node);
    $old_node = node_load($node->nid, $old_vid);
    $new_node = node_load($node->nid, $new_vid);
    // Generate table header (date, username, log message).
    $old_header = t('!date by !username', array(
      '!date' => l(format_date($old_node->revision_timestamp), "node/$node->nid/revisions/$old_node->vid/view", array('absolute' => 1)),
      '!username' => theme('username', array('account' => $node_revisions[$old_vid])),
    ));
    $new_header = t('!date by !username', array(
      '!date' => l(format_date($new_node->revision_timestamp), "node/$node->nid/revisions/$new_node->vid/view", array('absolute' => 1)),
      '!username' => theme('username', array('account' => $node_revisions[$new_vid])),
    ));
    $old_log = $old_node->log != '' ? '<p class="revision-log">' . filter_xss($old_node->log) . '</p>' : '';
    $new_log = $new_node->log != '' ? '<p class="revision-log">' . filter_xss($new_node->log) . '</p>' : '';
    $header = _diff_default_header($old_header, $new_header);
    $rows = array();
    if ($old_log || $new_log) {
      $rows['logs'] = array(
        array(
          'data' => $old_log,
          'colspan' => 2,
        ),
        array(
          'data' => $new_log,
          'colspan' => 2,
        ),
      );
    }
    $rows = array_merge($rows, _diff_body_rows($old_node, $new_node, $state));
    $build['diff_table'] = array(
      '#theme' => 'table__diff__standard',
      '#header' => $header,
      '#rows' => $rows,
      '#attributes' => array('class' => array('diff')),
      '#colgroups' => _diff_default_cols(),
      '#sticky' => FALSE,
    );
    $comment->content['comment_alter'] = $build;
  }
}

/**
 * Implements hook_comment_delete().
 */
function comment_alter_comment_delete($comment) {
  db_delete('comment_alter')
    ->condition('cid', $comment->cid)
    ->execute();
}

/**
 * No need to implement hook_comment_update(), hook_comment_presave(),
 * hook_comment_publish(), hook_comment_unpublish() nor
 * hook_comment_view_alter().
 */

/**
 * Implements hook_field_extra_fields().
 */
function comment_alter_field_extra_fields() {
  $return = array();
  foreach (node_type_get_types() as $type) {
    $comment_alter_fields = array_keys(variable_get('comment_alter_' . $type->type, array()));
    $weight = 0;
    foreach ($comment_alter_fields as $field_name) {
      $field = field_info_instance('node', $field_name, $type->type);
      $return['comment']['comment_node_' . $type->type]['form'][$field_name] = array(
        'label' => $field['label'],
        'description' => $field['description'],
        'weight' => $weight,
      );
      $weight++;
    }
  }
  return $return;
}
